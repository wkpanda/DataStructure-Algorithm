# 1. POSIX线程

## 1.1. 什么是线程

在一个程序中的多个执行路线就叫线程(thread).更准确的定义是:线程是一个进程内部的一个控制序列.所有的进程都至少有一个执行线程.

弄清楚fork系统调用和创建新系统之间的区别非常重要.当进程执行fork调用时,将创建出该进程的一份新副本.这个新进程拥有自己的变量和自己的PID,它的时间调度是独立的,它的执行(通常)几乎完全独立于父进程.当在进程中创建一个新线程时,新的执行线程将拥有自己的栈(因此也有自己的局部变量),但与它的创建者共享全局变量,文件描述符,信号处理函数和当前目录状态.

## 1.2. 线程的优点和缺点

在某些环境下,创建新线程要比创建新进程有更明显的优势.新线程的创建代价要比新进程小得多(虽然与其它操作系统相比,Linux在创建新进程方面的效率是很高的).

下面是一些线程使用的优点:

- 有时,让程序看起来好像是同时在做两件事情是很有用的.一个经典的例子是,在编辑文档的同时对文档中的单词个数进行实时统计.一个线程负责处理用户的输入并执行文本编辑工作,另一个(它也可以看到相同的文档内容)则不断刷新单词计数变量.第一个线程(甚至可以是第三个线程)通过这个共享的计数变量让用户了解自己的工作进展情况.另一个例子是一个多线程的数据库服务器,这是一种明显的单进程服务多用户的情况.它会在响应一些请求的同时阻塞另外一些请求,使之等待磁盘操作,从而改善整体上的数据吞吐量.对于数据库服务器来说,这个明显的多任务工作如果用多进程的方式很难做到高效,因为各个不同的进程必须紧密合作才能满足**加锁和数据一致性**方面的要求,而用多线程来完成就比用多进程要容易得多.
- 一个混杂着输入,计算和输出的应用程序,可以将这几个部分分离为3个线程来执行,从而改善程序执行的性能.当输入或输出进程等待连接时,另外一个线程可以继续执行.因此,如果一个进程在任一时刻最多只能做一件事情的话,线程可以让它在等待连接之类的事情的同时做一些其他有用的事情.一个需要同时处理多个网络连接的服务器应用程序也是一个天生适用于应用多线程的例子.
- 一般而言,线程之间的切换需要操作系统做的工作要比进程之间的切换少得多,因此多个线程对资源的需求要远小于多个进程.如果一个程序在逻辑上需要多个执行线程,那么在单处理器系统上把它运行为一个多线程程序才更符合实际情况.虽然如此,编写一个多线程程序的设计困难较大,不应等闲视之.

线程也有下面一些缺点:

- 编写多线程程序需要非常仔细的设计.在多线程程序中,因时序上的细微偏差或无意造成的变量共享而引发错误的可能性是很大的.
- 对多线程程序的调试要比单线程程序的调试困难得多,因为线程之间的交互非常难于控制.
- 将大量计算分成两个部分,并把这两个部分作为两个不同的线程来运行的程序在一台单处理器机器上并不一定运行得更快,除非计算却是允许它的不同部分可以被同时计算,而且计算它的机器拥有多个处理器核来支持真正的多处理.

## 1.3. 第一个线程程序

线程有一套完整的与其有关的函数库调用,它们中的大多数函数名都以pthread_开头,为了使用这些函数库调用,我们必须定义宏_REENTRANT,在程序中包含头文件pthread.h,并且在编译程序时需要用选项-lpthread来链接线程库.

在设计最初的UNIX和POSIX库例程时,人们假设每个进程中只有一个执行线程.一个明显的例子就是errno,该变量用于获取某个函数调用失败后的错误信息.在一个多线程程序中,默认情况下,只有一个```errno```变量供所有的线程共享.在一个线程准备获取刚才的错误代码时,该变量很容易被另一个线程中的函数调用所改变.类似的问题还存在于fputs之类的函数中,这些函数通常用一个全局性区域来缓存输出数据.

为解决这个问题,我们需要使用被称为**可重入**的例程.可重入代码可以被多次调用而仍然正常工作,这些调用可以来自不同的线程,也可以是某种形式的嵌套调用.因此,代码中的可重入部分通常只使用据变量,这使得每次对该代码的调用都将获得它自己唯一的一份数据副本.

编写多线程程序时,我们通过定义宏_REENTRANT来告诉编译器,我们需要可重入功能,这个宏的定义必须位于程序中的任何#include之前.它将为我们做3件事情,并且做得十分优雅,以至于我们一般不需要知道它到底做了哪些事.

- 它会对部分函数重新定义它们的可安全重入的版本,这些函数的名字一般不会发生改变,只是会在函数名后面添加_r字符串.例如,函数名gethosebyname将变为gethostbyname_r.
- stdio.h中原来以宏的形式实现的一些函数将变成可安全重入的函数
- 在errno.h中定义的变量errno现在将成为一个函数调用,它能够以一种多线程安全的方式来获取真正的errno值.
  
在程序中包含头文件pthread.h还向我们提供一些其他的将在代码中使用的定义和函数原型.最后,需要确保在程序中包含了正确的线程头文件,并且在编译程序时链接实现pthread函数的正确的线程库.

现在我们首先来看一个关于用于管理线程的新函数pthread_create,它的作用是创建一个新线程,类似于创建新进程的fork函数.它的定义如下所示:

```c
#include<pthread.h>

int pthread_create(pthread_t *thread,pthread_attr_t *attr,void *(*start_routine)(void *),void *arg);
```

这个函数定义看起来很复杂,其实用起来很简单.第一个参数是指向pthread_t类型数据的指针.线程被创建时,这个指针指向的变量中将被写入一个标识符,我们用该标识符来引用新线程.下一个参数用于设置参数的属性.我们一般不需要特殊的属性,所以只需设置该参数为NULL.最后两个参数分别告诉线程将要启动执行的函数和传递给该函数的参数.

> pthread_create和大多数pthread_系列函数一样,在失败时并未遵循UNIX函数的惯例返回-1,这种情况在UNIX函数中属于一少部分,除非你很有把握,在对错误代码进行检查之前一定要仔细阅读使用手册中的相关内容.

线程通过调用pthread_exit函数终止执行.这个函数的作用是,终止调用它的线程并返回一个指向某个对象的指针.注意,绝不能用它来返回一个指向局部变量的指针,因为线程调用该函数后,这个局部变量就不再存在了,这将引起严重的程序漏洞.pthrea_exit函数定义如下

```c
#include<pthread.h>

void pthread_exit(void *retval);
```

pthread_join函数的作用等价于进程中用来收集子进程信息的wait函数.这个函数的定义如下:

```c
#include<pthread.h>

int pthread_join(pthread_t th,void **thread_return);
```
第一个参数指定了将要等待的线程,线程通过pthread_create返回的标识符来指定.第二个参数是一个指针,它指向另一个指针,而后者指向线程的返回值.与pthread_create类似,这个函数在成功时返回0,失败时返回错误代码.

```c
/*一个简单的线程程序
这个程序创建一个新线程,新线程与原先的线程共享变量,并在结束时向原先的线程返回一个结果.
*/
#include<pthread.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>

void *thread_function(void *arg);
char message[] = "Hello World";

int main()
{
    int res;
    pthread_t a_thread;
    void *thread_result;

    res = pthread_create(&a_thread,NULL,thread_function,(void *)message);
    if(res != 0)
    {
        perror("Thread creation failed");
        exit(EXIT_FAILURE);
    }
    printf("Waiting for thread to finish...\n");
    res = pthread_join(a_thread,&thread_result);
    if(res != 0)
    {
        perror("Thread join failed");
        exit(EXIT_FAILURE);
    }
    printf("Thread joined,it returned %s\n",(char *)thread_result);
    printf("Message is now %s\n",message);
    exit(EXIT_SUCCESS);
}

void *thread_function(void *arg)
{
    printf("thread_function is running.Argument was %s\n",(char *)arg);
    sleep(3);
    strcpy(message,"Bye!");
    pthread_exit("Thank you for the CPU time");
}
```

1. 编译这个程序时,我们首先需要定义宏_REENTRANT.在少数系统上,可能还需要定义宏_POSIX_C_SOURCE,但一般不需要定义它.
2. 接下来必须链接正确的线程库.如果使用的是一个老的LINUX发行版,默认的线程库不是NPTL,你可能需要升级Linux发行版.
3. 在验证并安装了正确的文件后,现在可以编译和链接这个程序 ,使用的命令如下:

```powershell
cc -D_REENTRANT -I/usr/include/npt1 thread1.c
-o thread1 -L/usr/lib/npt1 -lpthread
如果你的系统默认使用的(很有可能)就是NPTL线程库,那么编译程序时就无需加上-I和-L选项,使用的命令如下所示:
cc -D_REENTRANT thread1.c -o thread -lpthread
```

4. 运行这个程序时,你将看到:
   
> Waiting for thread to finish...
> 
> thread_function is running.
> 
> Argument was Hello World
> 
> Thread joined,it returned Thank you for the CPU time
> 
> Message is now Bye!

### 实验解析

首先,我们定义了在创建线程时需要由它调用的一个函数的原型:

```c
void *thread_function(void *arg);
```

根据pthread_create的要求,它只有一个指向void的指针作为参数,返回的也是指向void的指针.在main函数中,我们首先定义了几个变量,然后调用pthread_create开始运行新线程.如下所示:
```c
pthread_t a_thread;
void *thread_result;

res = pthread_create(&a_thread,NULL,thread_function,(void *)message);
```

我们向pthread_create函数传递了一个pthread_t类型对象的地址,今后可以用它来引用这个新线程.我们不想改变默认的线程属性,所以设置第二个参数为NULL.最后两个参数分别为将要调用的函数和一个传递给该函数的参数.

如果这个调用成功了,就会有两个线程在运行.原先的线程(main)继续执行pthread_create后面的代码,而新线程开始执行thread_function函数.

原先的线程在查明新线程已经启动后,将调用pthread_join函数,如下所示:

```c
res = pthread_join(a_thread,&thread_result);
```

我们给该函数传递两个参数,一个是正在等待其结束的线程的标识符,另一个是指向线程返回值的指针.这个函数将**等到它所指定的线程终止后**才返回.然后主线程将打印新线程的返回值和全局变量message的值,最后退出.

新线程在thread_function函数中中开始执行,它先打印出自己的参数,休眠一会儿然后更新全局变量,最后退出并向主线程返回一个字符串.新进程修改了数组message,而原先的线程也可以访问该数组.如果我们调用的是fork而不是pthread_create,就不会有这样的效果.

## 1.4. 同步
我们将学习两种基本的方法.一种是**信号量**,它的作用如同看守一段代码的看门人;另一种是**互斥量**,它的作用如同保护代码段的一个互斥设备.这两种方法很相似,事实上,它们可以通过对方来实现.但在实际应用中,对于一些情况,可能使用信号量或互斥量中的一个更符合问题的语义,并且效果更好.例如,如果向控制任一时刻只有一个线程可以访问一些共享内存,使用互斥量就要自然得多.但在控制对一组相同对象的访问时--比如从5条可用的电话线中分配1条给某个线程的情况,就更适合使用计数信号量.具体选择哪种方法取决于个人偏好和相应的程序机制.

### 1.4.1. 用信号量进行同步

有两组接口函数用于信号量.一组取自POSIX的实时拓展,用于线程.另一组被称为系统V信号量,常用于进程的同步.这两组接口函数虽然很相近,但并不保证它们之间可以互换,而且它们使用的函数调用也各不相同.

荷兰计算机科学家Dijktra首先提出了信号量的概念.信号量是一个特殊类型的变量,它可以被增加或减少,但对其的关键访问被保证是原子操作,即使在一个多线程程序中也是如此.这意味着如果一个程序中有两个(或更多)的线程试图改变一个信号量的值,系统将保证所有的操作都将一次进行.但如果是普通变量,来自同一程序中的不同线程的冲突操作所导致的结果将是不确定的.

在这里,我们将介绍一种最简单的信号量--二进制信号量,它只有0和1两种取值.还有一种更通用的信号量--计数信号量,它可以有更大的取值范围.信号量一般要用来保护一段代码,使其每次只能被一个执行线程运行,要完成这个工作,就要使用二进制信号量.有时,我们希望可以允许有限数目的线程执行一段指定的代码,这就需要用到计数信号量.
